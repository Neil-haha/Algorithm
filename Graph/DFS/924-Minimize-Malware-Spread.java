class Solution {
	/*
		Method 1: DFS.
		
		1:	Create infected array by applying infection rules with all inital infected nodes.
			Each value in infected array represents the number of initial infected nodes which can infect the current node(index).
		2:	Iterate through initial infected nodes array, find the number of unique nodes which can be infected by the current initial infected node.
			Pick the maximum one with smaller node number.
	*/
	
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int[] infected = new int[graph.length];
        int max = 0;
        int ans = graph.length;
        
        for (int i = 0; i < initial.length; i++) {
            dfs(graph, initial[i], infected, new HashSet<>());
        }
        
        for (int i = initial.length - 1; i >= 0; i--) {
            int tmp = getOnes(graph, initial[i], infected, new HashSet<>());
            if (tmp > max) {
                max = tmp;
                ans = initial[i];
            } else if (tmp == max) {
                ans = Math.min(ans, initial[i]);
            }
        }
        
        return ans;
    } 
    
    private int getOnes(int[][] graph, int cur, int[] infected, Set<Integer> visited) {
        if (visited.contains(cur)) {
            return 0;
        }
        visited.add(cur);
        int ans = infected[cur] == 1 ? 1 : 0;
        for (int i = 0; i < graph[cur].length; i++) {
            if (graph[cur][i] == 1) {
                ans += getOnes(graph, i, infected, visited);
            }
        }
        return ans;
    }
    
    private void dfs(int[][] graph, int cur, int[] infected, Set<Integer> visited) {
        if (visited.contains(cur)) {
            return;
        }
        visited.add(cur);
        infected[cur] += 1;
        for (int i = 0; i < graph[cur].length; i++) {
            if (graph[cur][i] == 1) {
                dfs(graph, i, infected, visited);
            }
        }
    }
}